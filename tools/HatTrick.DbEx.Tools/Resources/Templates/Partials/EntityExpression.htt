    {?var:nullableAnnotation = $.EntityExpression.LanguageFeatures.Nullable.Annotation}
    {?var:nullableForgivingOperator = $.EntityExpression.LanguageFeatures.Nullable.ForgivingOperator}
    #region {($.EntityExpression.Name) => InsertSpaceOnCapitalizationAndToLower} entity expression
    public partial class {$.EntityExpression.Name}Entity : EntityExpression<{$.EntityExpression.Name}>
    {{
        #region internals
        private SelectExpressionSet{:nullableAnnotation} _inclusiveSelectExpressionSet;
        #endregion

        #region interface
        {#each $.Columns}
        {>("FieldExpression.Documentation") => GetTemplatePartial+}
        public readonly {$.FieldExpression.Name}Field {$.FieldExpression.Name};

		{/each}
        #endregion

        #region constructors
        public {$.EntityExpression.Name}Entity(string identifier, string name, SchemaExpression schema) : this(identifier, name, schema, null)
        {{
        }}

        private {$.EntityExpression.Name}Entity(string identifier, string name, SchemaExpression schema, string{:nullableAnnotation} alias) : base(identifier, name, schema, alias)
        {{
            {#each $.Columns}
            Fields.Add($"{{identifier}}.{$.Column.Name}", {$.FieldExpression.Name} = new {$.FieldExpression.Name}Field($"{{identifier}}.{$.Column.Name}", "{$.FieldExpression.Name}", this));
            {/each}
        }}
        #endregion

        #region methods
        public {$.EntityExpression.Name}Entity As(string name)
            => new {$.EntityExpression.Name}Entity(this.identifier, this.name, this.schema, name);

        protected override SelectExpressionSet GetInclusiveSelectExpression()
        {{
            {?var :applyComma = false}
            return _inclusiveSelectExpressionSet ?? (_inclusiveSelectExpressionSet = new SelectExpressionSet(
                {#each $.Columns}
                {+#if :applyComma},{/if}new {$.FieldExpression.SelectExpressionTypeName}({$.FieldExpression.Name})
                {? :applyComma = true}
				{/each}
            ));
        }}

        protected override SelectExpressionSet GetInclusiveSelectExpression(Func<string, string> alias)
        {{
            if (alias is null)
                throw new ArgumentNullException(nameof(alias));

            SelectExpressionSet{:nullableAnnotation} set = null;
            string{:nullableAnnotation} aliased = null;

            {#each $.Columns}
            aliased = alias(nameof({$.FieldExpression.Name}));
            set &= aliased != nameof({$.FieldExpression.Name}) ? new {$.FieldExpression.SelectExpressionTypeName}({$.FieldExpression.Name}).As(aliased) as {$.FieldExpression.SelectExpressionTypeName} : GetInclusiveSelectExpression().Expressions.Single(x => (x.Expression as IExpressionNameProvider){:nullableAnnotation}.Name == nameof({$.FieldExpression.Name}));

            {/each}
            return set;
        }}
		
        protected override InsertExpressionSet<{$.EntityExpression.Name}> GetInclusiveInsertExpression({$.EntityExpression.Name} {($.EntityExpression.Name) => ToCamelCase})
        {{
            return new InsertExpressionSet<{$.EntityExpression.Name}>({($.EntityExpression.Name) => ToCamelCase} 
                {#each $.Columns}
                {#if !$.Column.IsIdentity}
                {#if !$.Column.IsComputed}
                {#if $.FieldExpression.AllowInsert}
                ,new InsertExpression<{$.FieldExpression.Type.NullableAlias}>({($.FieldExpression.EntityExpression.Name) => ToCamelCase}.{$.FieldExpression.Name}, {$.FieldExpression.Name})
                {/if}
                {/if}
                {/if}
                {/each}                
            );
        }}

        protected override AssignmentExpressionSet GetAssignmentExpression({$.EntityExpression.Name} target, {$.EntityExpression.Name} source)
        {{
            AssignmentExpressionSet expr = new AssignmentExpressionSet();

            {#each $.Columns}
            {#if !$.Column.IsIdentity}
            {#if !$.Column.IsComputed}
            {#if $.FieldExpression.AllowUpdate}
            if (target.{$.FieldExpression.Name} != source.{$.FieldExpression.Name}) {{ expr &= {$.FieldExpression.Name}.Set(source.{$.FieldExpression.Name}); }}
            {/if}
            {/if}
            {/if}
            {/each}
            return expr;
        }}

        protected override void HydrateEntity(ISqlFieldReader reader, {$.EntityExpression.Name} {($.EntityExpression.Name) => ToCamelCase})
        {{
            {#each $.Columns}
            {($.FieldExpression.EntityExpression.Name) => ToCamelCase}.{$.FieldExpression.Name} = reader.ReadField(){:nullableForgivingOperator}.GetValue<{$.FieldExpression.Type.NullableAlias}>();
            {/each}
        }}
		#endregion

        #region classes
        {#each $.Columns}
        {>("FieldExpression") => GetTemplatePartial+}
        {/each}
        #endregion
    }}
    #endregion