{?var:nullableAnnotation = $.EntityExpression.LanguageFeatures.Nullable.Annotation}
{?var:nullableForgivingOperator = $.EntityExpression.LanguageFeatures.Nullable.ForgivingOperator}
{?var:identifierArgName = ("identifier", $.EntityExpression) => GetEntityArgName}
{?var:nameArgName = ("name", $.EntityExpression) => GetEntityArgName}
{?var:schemaArgName = ("schema", $.EntityExpression) => GetEntityArgName}
{?var:aliasArgName = ("alias", $.EntityExpression) => GetEntityArgName}
{?var:entityArgName = ("entity", $.EntityExpression) => GetEntityArgName}
{?var:identifierInterpolationArgName = ("{{x}}", "x", :identifierArgName) => Replace}
    #region {($.EntityExpression.Name) => InsertSpaceOnCapitalizationAndToLower} entity expression
    public partial class {$.EntityExpression.Name}Entity : EntityExpression<{$.EntityExpression.Name}>
    {{
        #region internals
        private SelectExpressionSet{:nullableAnnotation} _inclusiveSelectExpressionSet;
        #endregion

        #region interface
        {#each $.Columns}
        {>("FieldExpression.Documentation") => GetTemplatePartial+}
        public readonly {$.FieldExpression.Name}Field {$.FieldExpression.Name};

		{/each}
        #endregion

        #region constructors
        public {$.EntityExpression.Name}Entity(string {:identifierArgName}, string {:nameArgName}, Schema {:schemaArgName}) : this({:identifierArgName}, {:nameArgName}, {:schemaArgName}, null)
        {{
        }}

        private {$.EntityExpression.Name}Entity(string {:identifierArgName}, string {:nameArgName}, Schema {:schemaArgName}, string{:nullableAnnotation} {:aliasArgName}) : base({:identifierArgName}, {:nameArgName}, {:schemaArgName}, {:aliasArgName})
        {{
            {#each $.Columns}
            Attributes.Fields.Add($"{{identifier}}.{$.FieldExpression.Name}", {$.FieldExpression.Name} = new {$.FieldExpression.Name}Field($"{:identifierInterpolationArgName}.{$.FieldExpression.Name}", "{$.FieldExpression.Name}", this));
            {/each}
        }}
        #endregion

        #region methods
        public {$.EntityExpression.Name}Entity As(string alias)
            => new {$.EntityExpression.Name}Entity(this.Attributes.Identifier, this.Attributes.Name, this.Attributes.Schema, alias);

        protected override SelectExpressionSet GetInclusiveSelectExpression()
        {{
            {?var :applyComma = false}
            return _inclusiveSelectExpressionSet ?? (_inclusiveSelectExpressionSet = new SelectExpressionSet(
                {#each $.Columns}
                {+#if :applyComma},{/if}new {$.FieldExpression.SelectExpressionTypeName}({$.FieldExpression.Name})
                {? :applyComma = true}
				{/each}
            ));
        }}

        protected override SelectExpressionSet GetInclusiveSelectExpression(Func<string, string> {:aliasArgName})
        {{
            if (alias is null)
                throw new ArgumentNullException(nameof(alias));

            SelectExpressionSet{:nullableAnnotation} set = null;
            string{:nullableAnnotation} aliased = null;

            {#each $.Columns}
            aliased = {:aliasArgName}(nameof({$.FieldExpression.Name}));
            set &= aliased != nameof({$.FieldExpression.Name}) ? new {$.FieldExpression.SelectExpressionTypeName}({$.FieldExpression.Name}, aliased) as {$.FieldExpression.SelectExpressionTypeName} : GetInclusiveSelectExpression().Expressions.Single(x => (x.Expression as IExpressionNameProvider){:nullableAnnotation}.Name == nameof({$.FieldExpression.Name}));

            {/each}
            return set;
        }}
		
        protected override InsertExpressionSet<{$.EntityExpression.Name}> GetInclusiveInsertExpression({$.EntityExpression.Name} {:entityArgName})
        {{
            return new InsertExpressionSet<{$.EntityExpression.Name}>({:entityArgName} 
                {#each $.Columns}
                {#if !$.Column.IsIdentity}
                {#if !$.Column.IsComputed}
                {#if $.FieldExpression.AllowInsert}
                ,new InsertExpression<{$.FieldExpression.Type.NullableAlias}>({:entityArgName}.{$.FieldExpression.Name}, {$.FieldExpression.Name})
                {/if}
                {/if}
                {/if}
                {/each}                
            );
        }}

        protected override AssignmentExpressionSet GetAssignmentExpression({$.EntityExpression.Name} target, {$.EntityExpression.Name} source)
        {{
            AssignmentExpressionSet expr = new AssignmentExpressionSet();

            {#each $.Columns}
            {#if !$.Column.IsIdentity}
            {#if !$.Column.IsComputed}
            {#if $.FieldExpression.AllowUpdate}
            if (target.{$.FieldExpression.Name} != source.{$.FieldExpression.Name}) {{ expr &= {$.FieldExpression.Name}.Set(source.{$.FieldExpression.Name}); }}
            {/if}
            {/if}
            {/if}
            {/each}
            return expr;
        }}

        protected override void HydrateEntity(ISqlFieldReader reader, {$.EntityExpression.Name} {:entityArgName})
        {{
            {#each $.Columns}
            {:entityArgName}.{$.FieldExpression.Name} = reader.ReadField(){:nullableForgivingOperator}.GetValue<{$.FieldExpression.Type.NullableAlias}>();
            {/each}
        }}
		#endregion

        #region classes
        {#each $.Columns}
        {>("FieldExpression") => GetTemplatePartial+}
        {/each}
        #endregion
    }}
    #endregion