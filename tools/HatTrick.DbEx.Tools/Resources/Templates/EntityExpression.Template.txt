using System;
using System.Collections.Generic;
using {() => ResolveRootNamespace}Data;

{#each Schemas}
{#if !($) => IsIgnored}
namespace {() => ResolveRootNamespace}{($) => ResolveName}.DataService
{{
    using {() => ResolveRootNamespace}Data.{($) => ResolveName};
    using HatTrick.DbEx.Sql;
    using HatTrick.DbEx.Sql.Executor;
    using HatTrick.DbEx.Sql.Expression;
    using HatTrick.DbEx.Sql.Mapper;

	{#each ($) => ResolveConsolidatedTablesAndViews}
	{#if !($) => IsIgnored}
    #region {($) => InsertSpaceOnCapitalizationAndToLower}
    public partial class {($) => ResolveName}Entity : EntityExpression<{($) => ResolveName}>
    {{
        #region internals
		{#each Columns}
		{#if !($) => IsIgnored}
        private const string _{($) => ToCamelCase}FieldName = "{$.Name}";
		{/if}
		{/each}
        #endregion

        #region interface properties
		{#each Columns}
		{#if !($) => IsIgnored}
		{($, ..\$) => BuildFieldExpressionInterfaceProperty}
		{/if}
		{/each}
        #endregion

        #region constructors
		public {($) => ResolveName}Entity(SchemaExpression schema, Lazy<ISqlEntityMetadata> metadata): this(schema, metadata, null)
        {{
        }}

        private {($) => ResolveName}Entity(SchemaExpression schema, Lazy<ISqlEntityMetadata> metadata, string alias) : base("{(..\$) => ResolveName}.{($) => ResolveName}", schema, metadata, alias)
        {{
			{#each Columns}
			{#if !($) => IsIgnored}
			{($, ..\$, ..\..\$) => BuildEntityExpressionConstructorForFieldExpression}
			{/if}
			{/each}
        }}
        #endregion

        #region methods
        public {($) => ResolveName}Entity As(string name)
        {{
            return new {($) => ResolveName}Entity(this.Schema, this.MetadataResolver, name);
        }}

        protected override SelectExpressionSet GetInclusiveSelectExpression()
        {{
            return new SelectExpressionSet(
				{#each Columns}
				{#if !($) => IsIgnored}
                {($) => ResolveName}{#if !(..\$.Columns, $) => IsLast},{/if}
				{/if}
				{/each}
            );
        }}
		
        protected override InsertExpressionSet GetInclusiveInsertExpression({($) => ResolveName} {($) => ToCamelCase})
        {{
            return new InsertExpressionSet(
				{#each Columns}
				{#if !($) => IsIgnored}
				{#if !$.IsIdentity}				
                {($) => ResolveName}.Insert({(..\$) => ToCamelCase}.{($) => ResolveName}){#if !(..\$.Columns, $) => IsLast},{/if}
				{/if}
				{/if}
				{/each}
            );
        }}

        protected override AssignmentExpressionSet GetAssignmentExpression({($) => ResolveName} from, {($) => ResolveName} to)
        {{
            AssignmentExpressionSet expr = new AssignmentExpressionSet();

			{#each Columns}
			{#if !($) => IsIgnored}
			{#if !$.IsIdentity}
			{#if ($.Name) => NameRepresentsLastTouchedTimestamp}
            expr &= {($) => ResolveName}.Set(DateTime.UtcNow);
			{/if}
			{#if !($.Name) => NameRepresentsLastTouchedTimestamp}
			if (from.{($) => ResolveName} != to.{($) => ResolveName}) {{ expr &= {($) => ResolveName}.Set(to.{($) => ResolveName}); }}; 
			{/if}
			{/if}
			{/if}
			{/each}
			
            return expr;
        }}

        protected override void HydrateEntity({($) => ResolveName} {($) => ToCamelCase}, ISqlFieldReader reader, IValueMapper mapper)
        {{
			{#each Columns}
			{#if !($) => IsIgnored}
			{(..\$) => ToCamelCase}.{($) => ResolveName} = mapper.Map<{($, $.IsNullable) => ResolveAssemblyTypeName}>(reader.ReadField().Value);
			{/if}
			{/each}
        }}

		protected override void HydrateField({($) => ResolveName} {($) => ToCamelCase}, FieldExpression field, object value, IValueMapper mapper)
        {{
			{#each Columns}
			{#if !($) => IsIgnored}
			if (field == {($) => ResolveName})
			{{
				{(..\$) => ToCamelCase}.{($) => ResolveName} = mapper.Map<{($, $.IsNullable) => ResolveAssemblyTypeName}>(value);
				return;
			}}
			{/if}
			{/each}
        }}
		#endregion
    }}
    #endregion
	{/if}
    {/each}
}}
{/if}
{/each}